/* This grammar defines the SableCC 2.x input language. */

Package org.linguate.arboratecompiler; // Root Java package for generated files.

Helpers

/* These are character sets and regular expressions used in the definition of tokens. */

    digit = ['0' .. '9'];
    zero = '0';
    non_zero_digit = [digit - '0'];

    alpha = [['a' .. 'z'] + ['A' .. 'Z']];
    alphanumeric = [alpha + digit];
    tab = 9;
    cr = 13;
    lf = 10;
    eol = cr lf | cr | lf;        // This takes care of different platforms

    blank = (' ' | tab | eol)+;

States
    normal;

Tokens
    kw_function = 'function';
    kw_return = 'return';

    left_curly = '{';
    right_curly = '}';
    left_round = '(';
    right_round = ')';

    plus = '+';
    minus = '-';
    star = '*';
    slash = '/';

    equals = '=';

    comma = ',';
    semicolon = ';';

    int_string = non_zero_digit digit* | zero;
    identifier = alpha alphanumeric*;

    blank = blank;

Ignored Tokens 

    blank;

Productions
    program {-> program} =
        [functions]:func_decl_list { -> New program( [functions.func_decl]) };

    func_decl_list {-> func_decl*} =
        {single} [function]:func_decl { -> [function.func_decl] }
        | {multiple} [function]:func_decl [rest]:func_decl_list { -> [function.func_decl, rest.func_decl] };

    func_decl {-> func_decl} = 
        kw_function func_decl_name left_round func_decl_arg_list right_round left_curly func_body right_curly 
            { -> New func_decl(func_decl_name, func_decl_arg_list, [func_body.statement]) };

    func_decl_arg_list {-> func_decl_arg_list} =
         func_decl_arg_list_helper { -> New func_decl_arg_list([func_decl_arg_list_helper.func_decl_arg]) };

    func_decl_arg_list_helper {->  func_decl_arg*} =
        {none} { -> [] }
        | {single} [func_arg]:func_decl_arg { -> [func_arg.func_decl_arg] }
        | {multiple} [func_arg]:func_decl_arg comma [rest]:func_decl_arg_list_helper 
            { -> [func_arg.func_decl_arg, rest.func_decl_arg] };

    func_decl_arg {-> func_decl_arg} =
        func_decl_arg_type func_decl_arg_name 
            { -> New func_decl_arg(func_decl_arg_type, func_decl_arg_name) };

    func_body {-> statement*} = 
        {single} [function_body]:statement semicolon { -> [function_body.statement] }
        | {multiple} [function_body]:statement semicolon [rest]:func_body 
            { -> [function_body.statement, rest.statement] };

    statement {-> statement} =
        {declaration} var_decl_type var_decl_name 
            { -> New statement.declaration(var_decl_type, var_decl_name) }
        | {assignment} var_assign_name equals expr
            { -> New statement.assignment(var_assign_name, expr) }
        | {return} kw_return expr
            { -> New statement.return(expr) };

    expr {-> expr} =
        {add} [op1]:value plus [op2]:value { -> New expr.add(op1.value, op2.value)}
        | {subtract} [op1]:value minus [op2]:value { -> New expr.subtract(op1.value, op2.value)}
        | {multiply} [op1]:value star [op2]:value { -> New expr.multiply(op1.value, op2.value)}
        | {divide} [op1]:value slash [op2]:value { -> New expr.divide(op1.value, op2.value)};

    value {-> value} =
        {int_lit} int_string { -> New value.int_lit(int_string) }
        | {func_call} func_call_name left_round func_call_arg_list right_round
            { -> New value.func_call(func_call_name, func_call_arg_list) }
        | {var_fetch} var_fetch_name { -> New value.var_fetch(var_fetch_name)};

    func_call_arg_list {-> func_call_arg_list} =
        func_call_arg_list_helper { -> New func_call_arg_list([func_call_arg_list_helper.func_call_arg]) };

    func_call_arg_list_helper {-> func_call_arg*} =
        {none} { -> [] }
        | {single} [func_arg]:func_call_arg { -> [func_arg.func_call_arg] }
        | {multiple} [func_arg]:func_call_arg comma [rest]:func_call_arg_list_helper
            { -> [func_arg.func_call_arg, rest.func_call_arg] };

    func_call_arg {-> func_call_arg} =
        value;

    func_decl_name = identifier;
    func_decl_arg_type = identifier;
    func_decl_arg_name = identifier;

    func_call_name = identifier;

    var_decl_type = identifier;
    var_decl_name = identifier;
    var_assign_name = identifier;

    var_fetch_name = identifier;

Abstract Syntax Tree
    program = [functions]:func_decl*;

    func_decl = func_decl_name func_decl_arg_list statement*;

    func_decl_arg_list = func_decl_arg*;

    func_decl_arg = func_decl_arg_type func_decl_arg_name;

    statement =
        {declaration} var_decl_type var_decl_name
        | {assignment} var_assign_name expr
        | {return} expr;

    expr = 
        {add} [op1]:value [op2]:value
        | {subtract} [op1]:value [op2]:value
        | {multiply} [op1]:value [op2]:value
        | {divide} [op1]:value [op2]:value;

    value =
        {int_lit} int_string
        | {func_call} func_call_name func_call_arg_list
        | {var_fetch} var_fetch_name;

    func_call_arg_list = func_call_arg*;

    func_call_arg = value;

    func_decl_name = identifier;
    func_decl_arg_type = identifier; 
    func_decl_arg_name = identifier;

    func_call_name = identifier;

    var_decl_type = identifier;
    var_decl_name = identifier;
    var_assign_name = identifier;

    var_fetch_name = identifier;