/* This grammar defines the SableCC 2.x input language. */

Package org.linguate.arboratecompiler; // Root Java package for generated files.

Helpers

/* These are character sets and regular expressions used in the definition of tokens. */

    digit = ['0' .. '9'];
    non_zero_digit = [digit - '0'];

    alpha = [['a' .. 'z'] + ['A' .. 'Z']];
    alphanumeric = [alpha + digit];
    tab = 9;
    cr = 13;
    lf = 10;
    eol = cr lf | cr | lf;        // This takes care of different platforms

    blank = (' ' | tab | eol)+;

States
    normal;

Tokens
    kw_function = 'function';
    kw_return = 'return';

    left_curly = '{';
    right_curly = '}';
    left_round = '(';
    right_round = ')';

    plus = '+';
    minus = '-';
    star = '*';
    slash = '/';

    equals = '=';

    semicolon = ';';

    int_string = non_zero_digit digit*;
    identifier = alpha alphanumeric*;

    blank = blank;

Ignored Tokens 

    blank;

Productions
    program {-> program} =
        [functions]:func_decl_list { -> New program( [functions.func_decl]) };

    func_decl_list {-> func_decl*} =
        {single} [function]:func_decl { -> [function.func_decl] }
        | {multiple} [function]:func_decl [rest]:func_decl_list {-> [function.func_decl, rest.func_decl] };

    func_decl {-> func_decl} = 
        kw_function func_decl_name left_round right_round left_curly func_body right_curly { -> New func_decl(func_decl_name, [func_body.statement]) };

    func_body {-> statement*} = 
        {single} [function_body]:statement semicolon { -> [function_body.statement] }
        | {multiple} [function_body]:statement semicolon [rest]:func_body {-> [function_body.statement, rest.statement] };

    statement {-> statement} =
        {declaration} var_decl_type var_decl_name 
            { -> New statement.declaration(var_decl_type, var_decl_name) }
        | {assignment} var_assign_name equals expr
            { -> New statement.assignment(var_assign_name, expr) }
        | {return} kw_return expr
            { -> New statement.return(expr) };

    expr {-> expr} =
        {add} [op1]:value plus [op2]:value { -> New expr.add(op1.value, op2.value)}
        | {subtract} [op1]:value minus [op2]:value { -> New expr.subtract(op1.value, op2.value)}
        | {multiply} [op1]:value star [op2]:value { -> New expr.multiply(op1.value, op2.value)}
        | {divide} [op1]:value slash [op2]:value { -> New expr.divide(op1.value, op2.value)};

    value {-> value} =
        {int_lit} int_string { -> New value.int_lit(int_string) }
        | {func_call} func_call_name left_round right_round {-> New value.func_call(func_call_name) }
        | {var_fetch} var_fetch_name { -> New value.var_fetch(var_fetch_name)};

    func_decl_name = identifier;
    func_call_name = identifier;

    var_decl_type = identifier;
    var_decl_name = identifier;
    var_assign_name = identifier;

    var_fetch_name = identifier;

Abstract Syntax Tree
    program = [functions]:func_decl*;

    func_decl = func_decl_name statement*;

    func_call = func_call_name;

    statement =
        {declaration} var_decl_type var_decl_name
        | {assignment} var_assign_name expr
        | {return} expr;

    expr = 
        {add} [op1]:value [op2]:value
        | {subtract} [op1]:value [op2]:value
        | {multiply} [op1]:value [op2]:value
        | {divide} [op1]:value [op2]:value;

    value =
        {int_lit} int_string
        | {func_call} func_call_name
        | {var_fetch} var_fetch_name;

    func_decl_name = identifier;
    func_call_name = identifier;

    var_decl_type = identifier;
    var_decl_name = identifier;
    var_assign_name = identifier;

    var_fetch_name = identifier;